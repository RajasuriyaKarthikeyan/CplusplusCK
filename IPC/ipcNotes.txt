Communication can be of two types −

Between related processes initiating from only one process, such as parent and child processes.

Between unrelated processes, or two or more different processes.

Pipes − Communication between two related processes. The mechanism is half duplex meaning the first process communicates 
with the second process. To achieve a full duplex i.e., for the second process to communicate with the first process another 
pipe is required.

FIFO − Communication between two unrelated processes. FIFO is a full duplex, meaning the first process can communicate with the
second process and vice versa at the same time.

Message Queues − Communication between two or more processes with full duplex capacity. The processes will communicate with each 
other by posting a message and retrieving it out of the queue. Once retrieved, the message is no longer available in the queue.

Shared Memory − Communication between two or more processes is achieved through a shared piece of memory among all processes. 
The shared memory needs to be protected from each other by synchronizing access to all the processes.

Semaphores − Semaphores are meant for synchronizing access to multiple processes. When one process wants to access the memory 
(for reading or writing), it needs to be locked (or protected) and released when the access is removed. This needs to be repeated by 
all the processes to secure data.

Signals − Signal is a mechanism to communication between multiple processes by way of signaling. This means a source process will 
send a signal (recognized by number) and the destination process will handle it accordingly.


Required headers:
#include <sys/types.h>
#include <unistd.h>


code/text segment - normal codes
data segment - global and static variable
    uninitialized bss - uninitialized static and global
    initialized bss - initialized static and global
heap segment - dynmaic allocated variable/memory
stack segment - memoru of function and variables

size program.exe - provide all the segment info

fork() - system call to create prodess
        =0 means child process
        > 0 parent process
        < 0 process creation failed

A process can terminate in either of the two ways −
    Abnormally, occurs on delivery of certain signals, say terminate signal.
    Normally, using _exit() system call (or _Exit() system call) or exit() library function.

The difference between _exit() and exit() is mainly the cleanup activity. 
The exit() does some cleanup before returning the control back to the kernel, 
while the _exit() (or _Exit()) would return the control back to the kernel immediately.

#include <sys/wait.h> - headers
if the parent process exits before the child process, the inti process will beocme the parent of the child process
To avoid wait() system call need to be used
The wait() system call has limitation such as it can only wait until the exit of the next child. 
If we need to wait for a specific child it is not possible using wait(), however, it is possible using waitpid() system call.

The waitpid() system call would wait for specified children to terminate and return its termination status in the buffer 

waitid() system call. This system call waits for the child process to change state.


Process Group − Process group is a collection of one or more processes. A process group constitutes of one or more processes sharing 
the same process group identifier (PGID). A process group ID (PGID) is of the same type (pid_t) as the process ID. 
A process group has a process group leader, which is the process that creates the group and whose process ID becomes the 
process group ID of the group.

Sessions − It is a collection of various process groups.

Job Control − This permits a shell user to simultaneously execute multiple commands (or jobs), one in the foreground and all 
remaining in the background. It is also possible to move the jobs from the foreground to the background and vice-versa.



